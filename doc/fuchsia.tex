\documentclass[12pt,a4paper]{article}

\usepackage{amssymb,amsmath,color,enumitem,hyperref,verbatim,xspace}
\usepackage[affil-it]{authblk}

\bibliographystyle{halpha}
%\bibliographystyle{JHEP}

\setcounter{tocdepth}{2}
\setlist[description]{style=nextline}

\definecolor{fuchsia}{RGB}{140,0,130}
\def\F#1{\mathbf{#1}} % use this to style function names
\def\M#1{\mathbb{#1}} % use this to style matrix names
\def\functionitem#1#2{\item[$\F{#1}(#2)$]}

\input include/commands.tex

\input include/layout.tex
\input include/title.tex

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{abstract}
We present a program \fuchsia based on the Lee algorithm \cite{Lee15} which, given a system of first-order linear differential equations with rational function coefficients, constructs an equivalent system in the canonical form and corresponding transformation.
After such a reduction is successfully done the system can be trivially solved, which makes a reduction step crucial to obtain the solution.

In principle, \fuchsia can deal with any regular systems, however it's primary task is to reduce differential equations for master integrals which arise from Feynman diagrams.
It ensures that solutions contain regular singularities only due to the analyticity of S-matrix.

We discuss limitations and possible extensions of the proposed implementation.
\end{abstract}
\newpage

\input include/summary.tex
\newpage

\tableofcontents

\section{Introduction}

{\it Feynman integrals calculus: importance, methods to calculate (Smirnov's book \cite{Smi06}), differential equations method (progress \cite{Henn14}) .}

It has passed more than 50 years (?) since Richard Feynman proposed a diagrammatic approach for calculating perturbative processes in quantum field theories.
Since then Feynman integrals calculus has grown to a separate branch of the mathematical physics with a big community of scientists making research in this exciting field.
With no doubt we can say that none of the recent discoveries in the high-energy particle physics could happen without precise theoretical calculations, which are based in their core on the Feynman integrals calculation techniques. 
It is also clear that such techniques will play a key role for discoveries at the present and future high-energy colliders, hence their development and improvement is a very important task.

Recent progress in the computer industry made possible to automate calculation of Feynman integrals; problems which seemed impossible 10 years ago now are successfully solved with state-of-the-art computer algorithms and techniques.
Among the most popular of them is Feynman parameters~\cite{}, sector decomposition~\cite{}, Mellin-Barns~\cite{}, integration-by-parts~\cite{}, differential equations~\cite{}, and others; for a detailed review of these and other methods see~\cite{Smi06}.

{\it Analyticity of S-matrix and Fuchsian systems of DE. Reduction to Fuchsian form as an independent problem (Moser~\cite{Mos59},Barkatou~\cite{BP09}, \texttt{super\_reduce} in Maple), but mistreating $\infty$.}

{\it Integration-by-parts reduction, canonical form (Henn) \cite{Henn13}, Lee algorithm.}

This paper is organized as follows: in Section \ref{sec:2} we introduce notation and definitions followed by a brief review of the Lee method \cite{Lee15} and related algorithms implemented in \fuchsia.
In Section \ref{sec:3} we describe how to install \fuchsia and use it from different environments, depending on your goal and programming experience.
In Section \ref{sec:4} we discuss limitations and possible extensions of the current implemented and the method in general.


\section{Introduction to the Lee method}
\label{sec:2}


\subsection{Notation and definitions}

Let us consider a system of ODEs
\begin{equation}
\label{eq:df}
  \frac{\D \bar{f}}{\D x} = \M A(x,\eps)\,\bar{f},
\end{equation}
where $\bar{f}(x,\eps)$ is a vector of $n$ unknown functions (e.g., master integrals).
Elements of the $n \times n$ matrix  $\M A(x,\eps)$ are assumed to be rational functions of $x$ and $\eps$ and take the form
\begin{equation}
\label{eq:axeps}
  A(x,\eps) = \sum_k \frac{1}{(x-x_k)^{1+p_k}} \sum_{i=0}^\infty A_{ik}(\eps) (x-x_k)^i
\end{equation}
with {\em singular points} at $x = x_k$, where $k$ runs over a final set and $x_k$ is a complex number or $\infty$.
Let us emphasize here that behavior of the system at $x=\infty$ plays a crucial role in the Lee method and should be treated on the same footing as finite singular points.
We analyze singularities at $x=\infty$ by making $x\to1/x$ substitution and taking $x\to0$ limit; for more details see \cite{Bal08}.


\paragraph{Equivalent systems.}
The system \eqref{eq:df} is not unique in a sense that we can change the {\em basis} $\bar{f}$ using a {\em transformation} $\M T$ as
\begin{equation}
\label{eq:gtf}
  \bar{g} = \M T(x,\eps)\, \bar{f}.
\end{equation}
That leads to the {\em equivalent system} of ODEs
\begin{equation}
  \frac{\D \bar{g}}{\D x} = \M B(x,\eps)\,\bar{g},
\end{equation}
where
\begin{equation}
\label{eq:bta}
  \M B = \M T^{-1} \left( \M A \M T - \frac{\D \M T}{\D x} \right).
\end{equation}
In general case transformations $\M T(x,\eps)$ may have arbitrary form, however in the scope of this paper we assume elements of matrices $\M T(x,\eps)$ to be rational functions of $x$ and~$\eps$.
That guarantees that the equivalent matrix $\M B$ and hence all equivalent systems are in the rational form of eq.~\eqref{eq:axeps}.

\paragraph{Classification of singularities.}
For any system \eqref{eq:df}, taking into account a Laurent expansion of eq.~\eqref{eq:axeps}, we can define a rational number
\begin{equation}
\label{eq:mk}
  m_k(\M A) = p_k + \frac{r_k}{n} \ge 0
\end{equation}
as the {\em order} or {\em Poincar\'e rank} of $\M A$ at the point $x=x_k$, where $r_k = \rank(A_{0k})$ is the algebraic rank of $A_{0k}(\eps)$ such that $0 \le r_k \le n$; if $p_k + r_k/n < 0$ we set $m_k(\M A) = 0$.

In principle, orders of equivalent matrices are not the same, i.e., $m_k(\M A) \ne m_k(\M B)$.
For that reason, in order to make our analysis of singularities complete, we introduce the {\em minimum order} or {\em generalized Poincar\'e rank} of the matrix $\M A$, defined as
\begin{equation}
\label{eq:muk}
  \mu_k(\M A) = \min m_k(\M B), \text{ for } \forall \; \M T.
\end{equation}
If $\mu_k(\M A) < m_k(\M A)$ we say that the matrix $\M A(x,\eps)$ is {\em Moser-reducible}\footnote{After J\"urgen Moser and his study of reducibility in Fuchs' theory \cite{Mos59}.} (or shortly {\em reducible}) at the point $x=x_k$.

It is interesting to note that in the case of an ordinary differential equation of order~$n$, the minimum order $\mu_k$ can be computed explicitly from the power analysis of its coefficients (for more details see generalization of the Fuchs' theorem~\cite{Mos59}).
In the case of the system~\eqref{eq:df} such an explicit analysis can not be performed and we can use only a {\em recursive criterion} which consist in repeated application of the following steps unless a system is not reducible any more:
\begin{enumerate}
  \item Check if matrix $\M A(x,\eps)$ is reducible at $x=x_k$ (if no, stop).
  \item Find a transformation $\M T(x,\eps)$ to decrease the algebraic rank of $\M A(x,\eps)$ at $x=x_k$.
  \item Apply $\M T(x,\eps)$ and proceed to the step 1.
\end{enumerate}
We describe these steps in more details in the following section, what we would like to emphasize here is that in order to decrease a generalized Poincar\'e rank $\mu_k(\M A)$ to 0, we should repeat the step~2 at most $n\, m_k(\M A)$ times, which in the case of large $n$ may be a challenging computational problem.

Finally, based on the definitions \eqref{eq:mk} and~\eqref{eq:muk} we say that the point $x=x_k$ of $\M A(x,\eps)$ is
\begin{itemize}
  \item {\em regular point}, if $m_k(\M A) = 0$ and $\mu_k(\M A) = 0$;
  \item {\em apparent singularity}, if $m_k(\M A) > 0$ and $\mu_k(\M A) = 0$;
  \item {\em regular singularity}, if $0 < \mu_k(\M A) \le 1$;
  \item {\em irregular singularity}, if $\mu_k(\M A) > 1$.
\end{itemize}
The matrix $\M A$ is called {\em Fuchsian} if it does not contain irregular singularities at any point $x=x_k$ including $\infty$.
{\em [Comment on Barkatou and the way he treats $\infty$.]}


\subsection{Reduction to canonical form}

The goal of the method \cite{Lee15}, briefly described below, is to find a rational matrix $\M T(x,\eps)$ which transforms a system of ordinary differential equations with rational coefficients given by the matrix $\M A(x,\eps)$ to the equivalent system given by the matrix $\M M(x,\eps)$ in the {\em canonical form}~\cite{Henn13}, i.e., $\M M(x,\eps) = \eps\, \M M(x)$.
(Here and everywhere else in the text we assume that $\eps \to 0$, e.g., is a dimensional regularization parameter).
Once such a form is found the initial system $\M A$ can be easily solved as a Laurent series in $\eps$ parameter, which is of course the ultimate goal.

The whole method can be divided into three steps~\cite{Lee15}:
\begin{enumerate}
  \item Given a matrix $\M A(x,\eps)$, find a transformation $\M T$ such that the equivalent matrix $\M B(x,\eps)$, given by eq.~\eqref{eq:bta}, has a Fuchsian form.
  \item Given a matrix $\M A(x,\eps)$ in the Fuchsian form, find a transformation $\M T$ such that the equivalent matrix $\M B(x,\eps)$ is normalized, i.e., the eigenvalues of all its residues have the form $n \eps$, where $n$ is integer.
  \item Given a normalized matrix $\M A(x,\eps)$ in the Fuchsian form, find a transformation $\M T$ such that the equivalent matrix $\M B(x,\eps) = \eps \, \M B(x)$.
\end{enumerate}


\subsubsection{Fuchsification}

At first let us make a small remark.
The problem with definition in eq.~\eqref{eq:muk} is that a criterion to directly calculate $\mu_k(A)$ does not exist.
For that reason we can not say whether the point $x=x_k$ is regular or irregular singularity or whether matrix can be reduced to the Fuchsian form.
(However, for the $n$-th order ODE such a criterion exists, which is a generalization of Fuchs' theorem, see~\cite{Mos59}.)

Hence, the strategy is to gradually reduce a Poincar\'e rank of the system while the following criterion is satisfied (see \cite{Mos59}):

{\em If $m(\M A) > 1$ the system \eqref{eq:df} is reducible if and only if the polynomial}
\begin{equation}
\label{eq:red_cond}
  x^{r_k} \det\left(\frac{A_{0k}}{x} + A_{1k} - \lambda \M I\right) = 0
\end{equation}
{\em identically in $\lambda$ at $x=x_k$, where $r_k=\rank(A_{0k})$.}

The key element of the reduction is a {\em balance} transformation given by
\begin{equation}
  \M T(x) = \M B(\M P, x_k, a; x) = \M I - \M P + C \frac{x-a}{x-x_k} \M P
\end{equation}
which lowers the rank of $A_{0k}$, where $C$ is a constant and $\M P$ is a projector constructed of the generalized eigenvectors of $A_{0k}$, see~\cite[Section~3]{Lee15} (and \code{alg1x} function in \code{fuchsia.py}).
Applying this transformation several times, provided that \eqref{eq:red_cond} holds at every step, we eventually lower the rank of $A_{0k}$ until it becomes zero, hence lowering the Poincar\'e rank by one.
We continue this procedure until the Poincar\'e rank is zero, i.e., matrix is in the Fuchsian form at the point $x=x_k$.

The task of reducing a matrix to the Fuchsian form was also discussed in~\cite{BP99}, with a dedicated \texttt{Maple} package \texttt{ISOLDE} developed by the authors.
Additionally, a standard \texttt{Maple} package \texttt{DEtools} provides \code{moser\_reduce} and \code{super\_reduce} routines which \ldots

Let us mention, that in regular singular points solutions of \eqref{eq:df} grow at most like a finite power of $\abs{x}$, for that reason we 

\subsubsection{Normalization}

\subsubsection{Factorization}


\section{Using \fuchsia}
\label{sec:3}

\subsection{Installation}

To run \fuchsia you need \sage 7.0\footnote{Prior versions of \sage contain some critical bugs \fuchsia is sensitive to, later versions were not tested with \fuchsia.
For those reasons we strongly recommend you to use \sage 7.0.} to be installed on your computer.
Though, there are many pre-compiled packages of \sage for various \linux distributions, we recommend to compile it from sources which a straightforward process (despite of its size) and can be done without administration rights.
Visit \url{http://www.sagemath.org} for further installation instructions.

\sage is a free open-source mathematics software system licensed under GPL.
It is written in \python~2.7 and combines together many existing open-source projects among which are reliable tools for symbolic calculation: \texttt{GiNaC} and \texttt{Maxima}, which is heavily used in our code.

To install \fuchsia run the following command in your shell:

\code{\$ sage -pip install fuchsia}

This command installs the latest stable version of \fuchsia from the Python Package Index (PyPI) to your \sage environment.
If you are interested in the latest development version then visit \url{https://github.com/gituliar/fuchsia/}.

\subsection{Usage from the command line}

An easy way to use \fuchsia is to run \code{fuchsia.py} shell script, which has the following invocation signature:

\code{\$ fuchsia.py <action> <options>}

where
\begin{itemize}
  \item \code{<action>} is one of the algorithms described in the previous section, i.e., \code{fuchsify}, \code{normalize}, \code{factorize}, or auxiliary action \code{transform}, which applies a user-defined transformation to the given matrix.
  \item \code{<options>} are action-dependent options described in the help message printed with the help of \code{fuchsia.py --help} command.
\end{itemize}

In the following we provide a complete help information printed by \code{fuchsia.py --help}:
{\small
\begin{verbatim}
Fuchsia v16.4.8 (commit: 59b7847)
Authors: Oleksandr Gituliar, Vitaly Magerya
        
Usage:
    fuchsia [-hv] [-P <path>] <command> <args>...

Commands:
    fuchsify [-x <name>] [-m <path>] [-t <path>] <matrix>
        find a transformation that will transform a given matrix
        into Fuchsian form

    normalize [-x <name>] [-e <name>] [-m <path>] [-t <path>] <matrix>
        find a transformation that will transform a given Fuchsian
        matrix into normalized form

    factorize [-x <name>] [-e <name>] [-m <path>] [-t <path>] <matrix>
        find a transformation that will make a given normalized
        matrix proportional to the infinitesimal parameter

    transform [-x <name>] [-m <path>] <matrix> <transform>
        transform a given matrix using a given transformation

Options:
    -h          show this help message
    -v          be verbose and print additional information
    -P <path>   save profile report into this file
    -x <name>   use this name for the independent variable (default: x)
    -e <name>   use this name for the infinitesimal parameter (default: eps)
    -m <path>   save the resulting matrix into this file
    -t <path>   save the resulting transformation into this file

Arguments:
    <matrix>    read the input matrix from this file
    <transform> read the transformation matrix from this file
\end{verbatim}}


\subsection{Usage from \sage or \python}

\begin{description}

\functionitem{fuchsify}{\M M, x, seed=0}
Reduce a system defined by matrix $\M M$ and independent variable
$x$ to Fuchsian form. That is, make sure that the Poincare rank
of all singularities of the transformed matrix $\M M'$ are
$0$. Return a pair of values: the transformed matrix $\M M'$
and the transformation $\M T$. If the system is irreducible,
raise $FuchsiaError$.

\functionitem{normalize}{\M M, x, epsilon, seed=0}
Transform a Fuchsian system defined by matrix $\M M$, independent
variable $x$ and infinitesimal parameter $epsilon$ to a normalized
form. That is, make sure that eigenvalues of all matrix residues
of the transformed matrix $\M M'$ lie in the range $[-1/2, 1/2)$
in the limit $epsilon\to0$. Return a pair of values: the
transformed matrix $\M M'$ and the transformation $\M T$. If
such transformation can not be found, raise $FuchsiaError$.

\functionitem{factor\_epsilon}{\M M, x, epsilon, seed=0}
Transform a normalized system defined by matrix $\M M$, independent
variable $x$ and infinitesimal parameter $epsilon$ so that the
transformed matrix $\M M'$ is proportional to $epsilon$. Return a
pair of values: the transformed matrix $\M M'$ and the transformation
$\M T$. If such transformation can not be found, raise $FuchsiaError$.

\functionitem{simplify\_by\_jordanification}{\M M, x}
Try to simplify a system defined by matrix $\M M$ and independent
variable $x$ by constant transformations that transform leading
expansion coefficients of $\M M$ into their Jordan forms. Return a
pair of values: the simplified matrix $\M M'$ and the transformation
$\M T$. If none of the attempted transformations reduce the
complexity of $\M M$ (as measured by $\F{matrix\_complexity}$),
return the original matrix and the identity transformation.

\functionitem{simplify\_by\_factorization}{\M M, x}
Try to simplify a system defined by matrix $\M M$ and independent
variable $x$ by a constant transformation that extracts common
factors found in $\M M$ (if any). Return a pair of values:
the simplified matrix $\M M'$ and the transformation $\M T$.

\functionitem{matrix\_complexity}{\M M}
This function is used as a measure of matrix complexity by
$\F{fuchsify}$ and simplification function. Currently it is
defined as the length of textual representation of matrix $\M M$.

\functionitem{balance}{\M P, x_1, x_2, x}
Return a \textit{balance} transformation between points $x=x_1$
and $x=x_2$ using projector matrix $\M P$.

\functionitem{transform}{\M M, x, \M T}
Transform a system defined by matrix $\M M$ and independent
variable $x$ using transformation matrix $\M T$. Return the
transformed matrix $\M M'$.

\functionitem{balance\_transform}{\M M, \M P, x_1, x_2, x}
Same as $\F{transform}(\M M, x, \F{balance}(\M P, x_1, x_2, x))$,
but implemented more efficiently: since the inverse of
$\F{balance}(\M P, x_1, x_2, x)$ is $\F{balance}(\M P, x_2, x_1, x)$,
this function can avoid a time-consuming matrix inversion
operation that $\F{transform}$ must perform.

\functionitem{singularities}{\M M, x}
Find values of $x$ around which matrix $\M M$ has a singularity in
$x$. Return a dictionary with $\{x_i: p_i\}$ entries, where $p_i$
is the Poincare rank of $\M M$ at $x=x_i$. The set of singular points
can include $+Infinity$, if $\M M$ has a singularity at $x\to\infty$.

\functionitem{matrix\_c0}{\M M, x, x_0, p}
Return the 0-th coefficient of the series expansion of matrix
$\M M$ around $x=x_0$, assuming Poincare rank of $\M M$ at that
point is $p$. If $x_0$ is $+Infinity$, return the coefficient
at the highest power of $x$.

\functionitem{matrix\_c1}{\M M, x, x_0, p}
Return the 1-th coefficient of the series expansion of matrix
$\M M$ around $x=x_0$, assuming Poincare rank of $\M M$ at that
point is $p$. If $x_0$ is $+Infinity$, return the coefficient
at the second-to-highest power of $x$.

\functionitem{matrix\_residue}{\M M, x, x_0}
Return matrix residue of matrix $\M M$ at $x=x_0$, assuming that
Poincare rank of $\M M$ at $x=x_0$ is $0$. Return matrix residue
at infinity if $x=+Infinity$.

\functionitem{export\_matrix}{file, \M M}
Write matrix $\M M$ to a file-like object $file$ using MatrixMarket
array format. For description of this format see \cite{BPR96}.

\functionitem{export\_matrix\_to\_file}{filename, \M M}
Write matrix $\M M$ to a file $filename$ using MatrixMarket
array format.

\functionitem{import\_matrix}{file}
Read a symbolic matrix from a file-like object $file$, assuming
it is formatted using MatrixMarket array format.

\functionitem{import\_matrix\_from\_file}{filename}
Read a symbolic matrix from a file $filename$, assuming it is
formatted using MatrixMarket array format.

\end{description}

\section{Summary}
\label{sec:4}

{\it Prospects: non-rational transformations (e.g. sunrise graphs). }

\section*{Acknowledgment}

\bibliography{fuchsia}

\end{document}
