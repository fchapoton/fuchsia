\documentclass[12pt,a4paper]{article}

\usepackage{amssymb,amsmath,color,enumitem,hyperref,verbatim,xspace}
\usepackage[affil-it]{authblk}

\bibliographystyle{halpha}
%\bibliographystyle{JHEP}

\setcounter{tocdepth}{2}
\setlist[description]{style=nextline}

\definecolor{fuchsia}{RGB}{140,0,130}
\def\F#1{\mathbf{#1}} % use this to style function names
\def\M#1{\mathbb{#1}} % use this to style matrix names
\def\functionitem#1#2{\item[$\F{#1}(#2)$\hfill\textit{(function)}]}
\def\classitem#1{\item[$#1$\hfill\textit{(class)}]}

\input include/commands.tex

\input include/layout.tex
\input include/title.tex

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{abstract}
We present a program \fuchsia based on the Lee algorithm \cite{Lee15} which, given a system of first-order linear differential equations with rational function coefficients, constructs an equivalent system in the canonical form and corresponding transformation.
After such a reduction is successfully done the system can be trivially solved, which makes a reduction step crucial to obtain the solution.

In principle, \fuchsia can deal with any regular systems, however it's primary task is to reduce differential equations for master integrals which arise from Feynman diagrams.
It ensures that solutions contain regular singularities only due to the analyticity of S-matrix.

We discuss limitations and possible extensions of the proposed implementation.
\end{abstract}
\newpage

\input include/summary.tex
\newpage

\tableofcontents

\section{Introduction}

{\it Feynman integrals calculus: importance, methods to calculate (Smirnov's book \cite{Smi06}), differential equations method (progress \cite{Henn14}) .}

It has passed more than 50 years (?) since Richard Feynman proposed a diagrammatic approach for calculating perturbative processes in quantum field theories.
Since then Feynman integrals calculus has grown to a separate branch of the mathematical physics with a big community of scientists making research in this exciting field.
With no doubt we can say that none of the recent discoveries in the high-energy particle physics could happen without precise theoretical calculations, which are based in their core on the Feynman integrals calculation techniques. 
It is also clear that such techniques will play a key role for discoveries at the present and future high-energy colliders, hence their development and improvement is a very important task.

Recent progress in the computer industry made possible to automate calculation of Feynman integrals; problems which seemed impossible 10 years ago now are successfully solved with state-of-the-art computer algorithms and techniques.
Among the most popular of them is Feynman parameters~\cite{}, sector decomposition~\cite{}, Mellin-Barns~\cite{}, integration-by-parts~\cite{}, differential equations~\cite{}, and others; for a detailed review of these and other methods see~\cite{Smi06}.

{\it Analyticity of S-matrix and Fuchsian systems of DE. Reduction to Fuchsian form as an independent problem (Moser~\cite{Mos59},Barkatou~\cite{BP09}, \texttt{super\_reduce} in Maple), but mistreating $\infty$.}

{\it Integration-by-parts reduction, canonical form (Henn) \cite{Henn13}, Lee algorithm.}

This paper is organized as follows: in Section \ref{sec:2} we introduce notation and definitions followed by a brief review of the Lee method \cite{Lee15} and related algorithms implemented in \fuchsia.
In Section \ref{sec:3} we describe how to install \fuchsia and use it from different environments, depending on your goal and programming experience.
In Section \ref{sec:4} we discuss limitations and possible extensions of the current implemented and the method in general.


\section{Overview of the Lee method}
\label{sec:2}


\subsection{Notation and definitions}

Let us consider a system of ordinary differential equations (ODEs)
\begin{equation}
\label{eq:df}
  \frac{\D \bar{f}}{\D x} = \M A(x,\eps)\,\bar{f},
\end{equation}
where $\bar{f}(x,\eps)$ is a vector of $n$ unknown functions (e.g., master integrals) and  $\eps$ is an infinitesimally small parameter (e.g., a dimensional regulator in $d=4-2\eps$ dimensions).
Elements of the $n \times n$ matrix  $\M A(x,\eps)$ are assumed to be rational functions of $x$ and $\eps$ and take the form
\begin{equation}
\label{eq:axeps}
  {\M A}(x,\eps) = \sum_k \frac{1}{(x-x_k)^{1+p_k}} \sum_{i=0}^\infty {\M A}_{ki}(\eps) (x-x_k)^i
\end{equation}
with {\em singular points} at $x = x_k$, where $k$ runs over a finite set and $x_k$ is a complex number or $\infty$.
It is important to remember that behavior of the system at $x=\infty$ plays a crucial role in the Lee method and this point should be treated on the same footing as other singular points.
Singularities at $x=\infty$ can be analyzed by making a substitution $x\to1/x$ and taking a limit $x\to0$; for more details see \cite{Bal08}.


\paragraph{Equivalent systems.}
Let us change a {\em basis} of unknown functions from $\bar{f}(x,\eps)$ to $\bar{g}(x,\eps)$ by using a {\em transformation} $\M T(x,\eps)$ as
\begin{equation}
\label{eq:gtf}
  \bar{f} = \M T(x,\eps)\, \bar{g}.
\end{equation}
This leads to the {\em equivalent system} of ODEs
\begin{equation}
  \frac{\D \bar{g}}{\D x} = \M B(x,\eps)\,\bar{g},
\end{equation}
with a new matrix defined as
\begin{equation}
\label{eq:bta}
  \M B(x,\eps) = \M T^{-1} \left( \M A \M T - \frac{\D \M T}{\D x} \right).
\end{equation}
In general case transformations $\M T(x,\eps)$ may have arbitrary form, however in the scope of this paper we assume elements of matrices $\M T(x,\eps)$ to be rational functions of $x$ and~$\eps$.
This restriction guarantees that the equivalent matrix $\M B(x,\eps)$ and hence all equivalent systems are in the rational form as in eq.~\eqref{eq:axeps}.

\paragraph{Classification of singularities.}
For any system \eqref{eq:df}, taking into account a Laurent expansion of eq.~\eqref{eq:axeps}, we define a rational number
\begin{equation}
\label{eq:mk}
  m_k(\M A) = p_k + \frac{r_k}{n} \ge 0
\end{equation}
as the {\em order} or {\em Poincar\'e rank} of $\M A(x,\eps)$ at the point $x=x_k$, where $r_k = \rank(A_{k0})$ is the algebraic rank of $A_{k0}(\eps)$ such that $0 \le r_k \le n$; if $p_k + r_k/n < 0$ we set $m_k(\M A) = 0$.

In principle, orders of equivalent matrices are not the same, i.e., $m_k(\M A) \ne m_k(\M B)$.
For that reason, in order to make our analysis of singularities complete, we introduce the {\em minimum order} or {\em generalized Poincar\'e rank} of the matrix $\M A(x,\eps)$, defined as
\begin{equation}
\label{eq:muk}
  \mu_k(\M A) = \min m_k(\M B), \text{ for } \forall \; \M T.
\end{equation}
If $\mu_k(\M A) < m_k(\M A)$ we say that the matrix $\M A(x,\eps)$ is {\em Moser-reducible}\footnote{After J\"urgen Moser and his study of reducibility in Fuchs' theory \cite{Mos59}.} (or shortly {\em reducible}) at the point $x=x_k$.

It is interesting to note that in the case of an ordinary differential equation of order~$n$, the minimum order $\mu_k$ can be computed explicitly from the power analysis of its coefficients (for more details see generalization of the Fuchs' theorem~\cite{Mos59}).
In the case of the system~\eqref{eq:df} however such explicit analysis is not possible; and in order to find $\mu_k$ we can use only a {\em recursive criterion} which consist in repeated application of the following steps:
\begin{enumerate}
  \item Check if a matrix $\M A(x,\eps)$ is reducible at $x=x_k$, see eq.~\eqref{eq:red_cond}. Stop, if no.
  \item Find a transformation $\M T(x,\eps)$ to decrease the algebraic rank of $\M A(x,\eps)$ at $x=x_k$.
  \item Apply $\M T(x,\eps)$ and proceed to the Step 1.
\end{enumerate}
We describe these steps in more details in the following section, what we would like to emphasize here is that in order to decrease a generalized Poincar\'e rank $\mu_k(\M A)$ to 0, we should repeat the Step~2 at most $n\, m_k(\M A)$ times, which in the case of large $n$ may be a challenging computational problem.

Finally, based on the definitions \eqref{eq:mk} and~\eqref{eq:muk} we say that the point $x=x_k$ of $\M A(x,\eps)$ is
\begin{itemize}
  \item {\em regular point}, if $m_k(\M A) = 0$ and $\mu_k(\M A) = 0$;
  \item {\em apparent singularity}, if $m_k(\M A) > 0$ and $\mu_k(\M A) = 0$;
  \item {\em regular singularity}, if $0 < \mu_k(\M A) \le 1$;
  \item {\em irregular singularity}, if $\mu_k(\M A) > 1$.
\end{itemize}
The matrix $\M A(x,\eps)$ is called {\em Fuchsian} if it does not contain irregular singularities at any point $x=x_k$ including $\infty$.
{\em [Comment on Barkatou and the way he treats $\infty$.]}


\subsection{Reduction to canonical form}

In the previous section we have introduced notation and key definitions related to the Fuchsian theory of ODEs.
Now we are ready to review a reduction method proposed by Roman Lee in~\cite{Lee15}.
With its help we can construct a rational transformation $\M T(x,\eps)$ which transforms a system of ordinary differential equations with rational coefficients given by the matrix $\M A(x,\eps)$ to the equivalent system given by the matrix $\M M(x,\eps)$ which is Fuchsian and {\em canonical}~\cite{Henn13}, i.e., $\M M(x,\eps) = \eps\, \M M(x)$.
After the canonical form $\M M(x,\eps)$ of the initial system $\M A(x,\eps)$ is found we can easily solve it as a Laurent series in $\eps$ and restore solutions for the initial system $\M A(x,\eps)$ --- which is our ultimate goal --- by solving a linear system of equations.

The whole method can be divided into three main steps as described in the rest of this section.

\begin{enumerate}
  \item Given a matrix $\M A(x,\eps)$, find a rational transformation $\M T(x,\eps)$ such that the equivalent matrix $\M B(x,\eps)$ is Fuchsian.
  \item Given a Fuchsian matrix $\M A(x,\eps)$ with eigenvalues of all its residues in  $n+m\eps$ form, where $n$ is integer, find a rational transformation $\M T(x,\eps)$ such that the equivalent matrix $\M B(x,\eps)$ is Fuchsian and normalized.
  \item Given a Fuchsian and normalized matrix $\M A(x,\eps)$, find a rational transformation $\M T(x,\eps)$ such that the equivalent matrix is canonical, i.e., $\M B(x,\eps) = \eps \, \M B(x)$.
\end{enumerate}


\subsubsection{Fuchsification}
\label{sec:fuchs}

By {\em fuchsification} we mean to find a rational transformation $\M T(x,\eps)$ which transforms a matrix $\M A(x,\eps)$, at all singular points $x=x_k$ including $\infty$, to the Fuchsian form given by a matrix $\M B(x,\eps)$.

The strategy is exactly the same as the recursive criterion for calculating $\mu_k(\M A)$ discussed above, but now the main point is to find $\M T(x,\eps)$ rather than $\mu_k(\M A)$.
Moreover, we expect $\mu_k(\M A) = 0$ since solutions of our ODEs correspond to Feynman integrals which are known to have only logarithmic singularities, hence be solution of some Fuchsian ODEs.

For completeness let us list a criterion to reduce an algebraic rank of $\M A(x,\eps)$ at $x=x_k$ as proposed by Moser \cite{Mos59}:

\textbf{Theorem 1.}
{\em If $m(\M A) > 1$ the system \eqref{eq:df} is reducible if and only if the polynomial}
\begin{equation}
\label{eq:red_cond}
  x^{r_k} \det\left(\frac{\M A_{k0}}{x} + \M A_{k1} - \lambda \,\M I\right) = 0
\end{equation}
{\em identically in $\lambda$ at $x=x_k$, where $r_k=\rank(\M A_{k0})$ and $\M A_{k0}$ is nilpotent, i.e., has only zero eigenvalues.}

If one of these conditions fail then $x=x_k$ is an irregular singularity.
Otherwise, we proceed with constructing an appropriate transformation, which plays a crucial role in the Lee method and is referred as a {\em $\M Q$-balance} between $x_k$ and $x_0$, given by
\begin{equation}
  \label{eq:bal}
  \M T(x,\eps) = \M B(\M Q(\eps), x_k, x_0; x) = \M I - \M Q(\eps) + c \frac{x-x_0}{x-x_k} \M Q(\eps),
\end{equation}
where $x_0$ and $c$ are numbers and $\M Q(\eps)$ is a projector constructed of the generalized eigenvectors of $\M A_{k0}(\eps)$.
For the complete description of how to build an appropriate projector $\M Q(\eps)$ see~\cite[p.~9]{Lee15}.

Let us comment on some properties of the transformation in eq.~\eqref{eq:bal}.
\begin{itemize}
  \item When appropriately constructed the $\M Q$-balance decreases $\rank(\M A_{00})$ at $x=x_0$ and does not increase $m_k(\M A)$ at any other point $x=x_k$.
  \item It may happen, that it is not possible to construct an appropriate $\M Q$-balance between $x=x_0$ and any other existing singular point $x=x_k$.
        In that case, a new, apparent, singular point is introduced and used to lower the rank at $x=x_0$.
        Though, introduction of a new singular point may look like a complication, in fact it is not, since all apparent singularities disappear during the normalization step.
\end{itemize}

In \fuchsia, fuchsification step is implemented by \code{fuchsify} and \code{fuchsify\_by\_blocks} routines, which are described in details in Section~\ref{sec:usage_py}.

Finally, let us mention, that a similar problem of reducing a Poincar\'e rank of rational matrices was actively studied by Barkatou and co-authors, e.g., see~\cite{BP99}.
Together with Pfl\"ugel they developed algorithms implementing their method~\cite{BP99} and available in the standard \texttt{Maple} package \texttt{DEtools} as \code{moser\_reduce} and \code{super\_reduce} routines.


\subsubsection{Normalization}
\label{sec:norm}

By {\em normalization} we mean to find a rational transformation $\M T(x,\eps)$ which transforms a given Fuchsian matrix with eigenvalues of all its residues in the form $n + m \, \eps$, to the equivalent Fuchsian matrix with eigenvalues in the form $m \, \eps$, where $n$ is integer.

As in the previous step a corresponding transformation can be found by constructing an appropriate balance~\eqref{eq:bal} as described in~\cite[p.~11]{Lee15}.
Here another property of the balance transformation is used:
\begin{itemize}
  \item When appropriately constructed the balance $\M B(\M P(\eps), x_1, x_2; x)$ decreases an eigenvalue of $\M A_{10}(\eps)$ by 1 and increases another eigenvalue of $\M A_{20}(\eps)$ by 1 without affecting Poincar\'e rank at the points $x=x_1$ and $x=x_2$.
\end{itemize}
Since the sum of eigenvalues of all residues of a given matrix is zero, by applying appropriately constructed balances, we find a transformation which gives $m = 0$.

It may happen, that some $m$'s in the initial matrix are non-integer numbers which leads to fail of the algorithm based on balance transformations.
In this case we suggest to look for some variable change which leads to the appropriate form of $m$.
Unfortunately, we can not provide a general algorithm how to choose such substitution, for the moment we use a try-fail approach.

In \fuchsia, normalization step is implemented by \code{normalize} and \code{fuchsify\_by\_blocks} routines, which are described in details in Section~\ref{sec:usage_py}.


\subsubsection{Factorization}
\label{sec:fact}
By {\em factorization} we mean to find a rational transformation $\M T(\eps)$ which transforms a given Fuchsian and normalized matrix to the canonical form.
Let us assume that $\M T(\eps)$ is such a matrix, then an equivalent matrix after transformation, according to eq.~\eqref{eq:bta}, is given by
\begin{equation}
  \M B(x,\eps) = \eps\, \sum_i \frac{\M B_i}{x-x_i} = \sum_i \M T^{-1}(\eps) \frac{\M A_i(\eps)}{x-x_i} \M T(\eps),
\end{equation}
or explicitly
\begin{equation}
  \M B_i = \M T^{-1}(\eps) \frac{\M A_i(\eps)}{\eps} \M T(\eps), \quad \text{for} \quad i=1..k.
\end{equation}
Since $\M B_i$ is constant for any $\eps$, in order to find components of $n\times n$ matrix $\M T(\eps)$, we write a system of linear equations for some fixed value of $\mu$ at an every singular point $x=x_i$, i.e.,
\begin{equation}
  \frac{\M A_i(\eps)}{\eps} \M T(\eps,\mu) = \M T(\eps,\mu) \frac{\M A_i(\mu)}{\mu},
\end{equation}
where we now treat components of $\M T(\eps,\mu) = \M T(\eps) \; \M T^{-1}(\mu)$ as unknown variables.
The initial transformation we are looking for is then given by $\M T(\eps) = \M T(\eps,\mu_0)$ for some arbitrary chosen number $\mu = \mu_0$, provided that $\M T(\eps, \mu_0)$ is not singular.

In \fuchsia this step is implemented as \code{factorize} routine, see Section~\ref{sec:usage_py}.

\subsubsection{Block-triangular form}
\label{sec:blockreduce}

It is usually happens that a matrix which defines an ODEs is sparse, i.e., has many zeros.
We can use that fact to shuffle the matrix to a block-triangular form.
This can drastically improve fuchsification and normalization steps described in previous sections.
(You will find \code{block\_triangular\_form} routine in \fuchsia which finds a block-triangular form of a given matrix.)
Below we describe an algorithm to fuchsify and normalize a given matrix taking into account its block-triangular form; for more details see~\cite[Section~7]{Lee15}, similar ideas were also discussed in \cite{Git15}.

Let us consider a block-triangular matrix of the form
\begin{equation}
\label{eq:bdiag}
\M A(x,\eps)=
\left(
\begin{matrix}
  \M A_{11} & 0      & 0 & 0 & 0
\\
  \M A_{21} & \M A_{22} & 0 & 0 & 0
\\
  \M A_{31} & \M A_{32} & \M A_{33} & 0 & 0
\\
  \vdots & \cdots & \cdots & \ddots & 0
\\
  \M A_{k1} & \M A_{k2} & \M A_{k3} & \cdots & \M A_{kk}
\end{matrix}
\right)
.
\end{equation}

We start by reducing {\bf diagonal blocks} given by $n_i \times n_i$ matrices $\M A_{ii}(x,\eps)$ to canonical form as described in the previous sections, i.e., by fuchsification, normalization, and factorization.
Since a characteristic polynomial of a block-triangular matrix is a product of characteristic polynomials of its diagonal blocks, i.e.,
\begin{equation}
  \det(\M A(x,\eps)-\lambda \M I) = \det(\M A_{11}(x,\eps) - \lambda\M I) \ldots  \det(\M A_{kk}(x,\eps) - \lambda \M I)
  ,
\end{equation}
after we put each diagonal block to the canonical form the whole matrix became normalized.

Next, we fuchsify {\bf non-diagonal blocks} given by rectangular matrices $\M A_{ij}(x,\eps)$, $i \ne j$ as described in~\cite[Section~7]{Lee15}.

In \fuchsia these two steps are implemented by \code{fuchsify\_by\_blocks} function.

Finally, in order to factorize a whole matrix we proceed as described in Section~\ref{sec:fact}.


\section{Using \fuchsia}
\label{sec:3}

\subsection{Installation}

To run \fuchsia you need \sage version 7.0 or higher to be installed on your computer.
You can find installation instructions for \sage over at it's website, \url{http://www.sagemath.org}.
\footnote{
    Some \linux distributions have \sage available in their package repositories; we do not recomment using those.
    A number of \maxima releases contain bugs which \fuchsia is sensitive to, and so far the official \sage builds have avoided those releases (unlike a number of \linux distributions).
}

\sage is a free and open-source Computer Algebra System licensed under GPL.
It is written in \python~2.7 and combines together a number of existing open-source mathematical systems and libraries like \texttt{Maxima}, \texttt{Magma}, \texttt{Singular} and others with the goal of providing the best free CAS.
In particular our code heavily relies on the interface to \maxima.

To install \fuchsia run the following command in your shell:

\begin{verbatim}
    $ sage -pip install fuchsia
\end{verbatim}

This will install the latest stable version of \fuchsia from the Python Package Index (PyPI) to your \sage environment.
If you are interested in the latest development version then visit \url{https://github.com/gituliar/fuchsia/}.

\subsection{Usage from the command line}

An easy way to use \fuchsia is to run \code{fuchsia.py} shell script, which has the following invocation signature:

\begin{verbatim}
    $ fuchsia.py <action> <options>
\end{verbatim}

where
\begin{itemize}
  \item \code{<action>} is one of the algorithms described in the previous section, i.e., \code{fuchsify}, \code{normalize}, \code{factorize}, or auxiliary action \code{transform}, which applies a user-defined transformation to the given matrix.
  \item \code{<options>} are action-dependent options described in the help message printed with the help of \code{fuchsia.py --help} command.
\end{itemize}

In the following we provide a complete help information printed by \code{fuchsia.py --help}:
{\small
\begin{verbatim}
Fuchsia v16.5.25 (commit: e9aaaf6)
Authors: Oleksandr Gituliar, Vitaly Magerya

Usage:
    fuchsia [-hv] [-f <fmt>] [-l <path>] [-P <path>] <command> <args>...

Commands:
    reduce [-x <name>] [-e <name>] [-m <path>] [-t <path>] <matrix>
        find a canonical form of the given matrix

    fuchsify [-x <name>] [-m <path>] [-t <path>] <matrix>
        find a transformation that will transform a given matrix
        into Fuchsian form

    normalize [-x <name>] [-e <name>] [-m <path>] [-t <path>] <matrix>
        find a transformation that will transform a given Fuchsian
        matrix into normalized form

    factorize [-x <name>] [-e <name>] [-m <path>] [-t <path>] <matrix>
        find a transformation that will make a given normalized
        matrix proportional to the infinitesimal parameter

    sort [-m <path>] [-t <path>] <matrix>
        find a block-triangular form of the given matrix

    transform [-x <name>] [-m <path>] <matrix> <transform>
        transform a given matrix using a given transformation

    changevar [-x <name>] [-m <path>] <matrix> <expr>
        transform matrix by susbtituting free variable by a
        given expression

Options:
    -h          show this help message
    -f <fmt>    matrix file format: mtx or m (default: mtx)
    -l <path>   save log information to this file
    -v          be verbose and print log information
    -P <path>   save profile report into this file
    -x <name>   use this name for the free variable (default: x)
    -e <name>   use this name for the infinitesimal parameter (default: eps)
    -m <path>   save the resulting matrix into this file
    -t <path>   save the resulting transformation into this file

Arguments:
    <matrix>    read the input matrix from this file
    <transform> read the transformation matrix from this file
    <expr>      arbitrary expression
\end{verbatim}}


\subsection{Usage from \sage or \python}
\label{sec:usage_py}

You can use \fuchsia as a library by starting \sage prompt and importing \texttt{fuchsia} module like this:

\begin{verbatim}
    $ sage
    ┌────────────────────────────────────────────────────────────────────┐
    │ SageMath Version 7.1, Release Date: 2016-03-20                     │
    │ Type "notebook()" for the browser-based notebook interface.        │
    │ Type "help()" for help.                                            │
    └────────────────────────────────────────────────────────────────────┘
    sage: from fuchsia import *
\end{verbatim}

Read the next section for the list of functions you'll get after import.
To give you a feel for the API, let's try reducing an example matrix.

\begin{verbatim}
    sage: x, eps = var("x eps")
    sage: M = matrix([
      [(2-eps)/x, 0, 0],
      [x/(x-1), eps/x, 0],
      [(1+2*eps)/x**3, 0, (1+eps)/x/(x+1)]
    ])
\end{verbatim}

First, let's see where the singularities of this matrix lie:

\begin{verbatim}
    sage: singularities(M, x)
    {-1: 0, 0: 2, 1: 0, +Infinity: 1}
\end{verbatim}

So, 4 singularites in total, with Poincar\'e rank being 2 at $\code{x}=2$, 1 at $\code{x}=\infty$ and 0 everywhere else.
To get rid of non-zero ranks (thus transforming the system into Fuchsian form) we'll need to fuchsify this matrix like so:

\begin{verbatim}
    sage: Mf, Tf = fuchsify(M, x)
    sage: Mf
    [ -(eps - 2)/x           0                          0]
    [   -1/(x - 1)  (eps -1)/x                          0]
    [(2*eps + 1)/x           0  (eps + 2*x + 3)/(x^2 + x)]
    sage: singularities(Mf, x)
    {-1: 0, 0: 0, 1: 0, +Infinity: 0}
\end{verbatim}

So far, so good. Now, let's take a look at the eigenvalues of \code{Mf} residues:

\begin{verbatim}
    sage: [matrix_residue(Mf, x, x0).eigenvalues()
    ....:  for x0 in [-1, 0, 1, Infinity]]
    [[-eps - 1, 0, 0],
     [-eps + 2, eps - 1, eps + 3],
     [0, 0, 0],
     [-eps + 1, eps - 2, -2]]
\end{verbatim}

Many of these eigenvalues are not equal to zero in limit $\code{eps}\to0$, so \code{Mf} is not normalized.
On the other hand, all of the eigenvalues are of the form $n + m*\code{eps}$, so there's a chance we'll be able to normalize \code{Mf}.
Let's try:

\begin{verbatim}
    sage: Mn, Tn = normalize(Mf, x, eps)
    sage: Mn
    [-eps/x                                                            ...
    [(4*eps^3 - 8*eps^2 - (4*eps^2 - 6*eps + 3)*x + 5*eps)/((4*eps^3 - ...
    [((2*eps + 1)*x + 3*eps + 1)/(x^2 + x)                             ...
    sage: [matrix_residue(Mn, x, x0).eigenvalues()
    ....:  for x0 in [-1, 0, 1, Infinity]]
    [[-eps, 0, 0],
     [-eps, eps, eps],
     [0, 0, 0],
     [-eps, eps, 0]]
\end{verbatim}

So, the matrix is normalized, but it grew quite a bit larger.
This happens.
Sometimes it's possible to simplify it a bit like so:

\begin{verbatim}
    sage: Ms, Ts = simplify_by_jordanification(Mn, x)
    sage: Ms
    [               -eps/x      0              0]
    [            1/(x - 1)  eps/x              0]
    [1/2*(eps + 1)/(x + 1)      0  eps/(x^2 + x)]
\end{verbatim}

That's much better.

Finally, we need to factorize \code{Ms} to complete the reduction:

\begin{verbatim}
    sage: Mr, Tr = factorize(Ms, x, eps)
    sage: Mr
    [         -eps/x      0              0]
    [1/4*eps/(x - 1)  eps/x              0]
    [5/8*eps/(x + 1)      0  eps/(x^2 + x)]
\end{verbatim}

This is the fully transformed matrix.
As you can see, it is both proportional to \code{eps} and Fuchsian.
To make sure we got it right, we can double-check the full transformation:

\begin{verbatim}
    sage: T = (Tf*Tn*Ts*Tr).simplify_rational()
    sage: (Mr - transform(M, x, T)).is_zero()
    True
\end{verbatim}

Note that we're using construct \texttt{(A - B).is\_zero()} to compare matrices instead of the more obvious \texttt{bool(A == B)}.
This is a \sage idiosyncrasy; the more obvious way compares symbolic matrices only structually.

Of course, you don't need to walk through all these steps yourself every time.
Normally, you just need to call this one function to do all the reduction work:

\begin{verbatim}
    sage: MM, TT = canonical_form(M, x, eps)
    sage: MM
    [                          -eps/x      0              0]
    [                 1/4*eps/(x - 1)  eps/x              0]
    [1/4*(9*eps*x + 13*eps)/(x^2 + x)      0  eps/(x^2 + x)]
    sage: (MM - transform(M, x, TT)).is_zero()
    True
\end{verbatim}

Notice that this matrix is slightly more complex than the one we obtained step by step above.
This also happens.
The final form we're computing is not unique, and it will be different depending on the precise sequence of reduction steps you've taken.

Also, many of the transformations take a special $seed$ parameter to control the order of operations they perform internally.
By supplying different seeds, you will obtain different results as well.

\subsubsection{Function reference}

\begin{description}

\functionitem{canonical\_form}{\M M, x, epsilon, seed=0}
Fully reduce a system defined by matrix $\M M$, independent variable $x$ and infinitesimal parameter $epsilon$.
Return a pair of values: the transformed matrix $\M M'$ and the transformation matrix $\M T$.
Raise $FuchsiaError$ if the system is irreducible.

Reduction is performed by first coverting $\M M$ to block-triangular form, then reducing the diagonal blocks via $\F{fuchsify}$, $\F{normalize}$ and $\F{factorize}$, reducing off-diagonal blocks as described in Section~\ref{sec:blockreduce}, and finally factorizing $epsilon$ via $\F{factorize}$.

\functionitem{fuchsify}{\M M, x, seed=0}
Reduce a system defined by matrix $\M M$ and independent variable $x$ to Fuchsian form.
That is, make sure that Poincar\'e ranks of all singularities of the transformed matrix $\M M'$ are $0$.
Return a pair of values: the transformed matrix $\M M'$ and the transformation $\M T$.
If the system is irreducible, raise $FuchsiaError$.

\functionitem{normalize}{\M M, x, epsilon, seed=0}
Transform a Fuchsian system defined by matrix $\M M$, independent variable $x$ and infinitesimal parameter $epsilon$ to a normalized form.
That is, make sure that eigenvalues of all matrix residues of the transformed matrix $\M M'$ lie in the range $[-1/2, 1/2)$ in the limit $epsilon\to0$.
Return a pair of values: the transformed matrix $\M M'$ and the transformation $\M T$.
If such transformation can not be found, raise $FuchsiaError$.

\functionitem{factorize}{\M M, x, epsilon, seed=0}
Transform a normalized system defined by matrix $\M M$, independent variable $x$ and infinitesimal parameter $epsilon$ so that the
transformed matrix $\M M'$ is proportional to $epsilon$.
Return a pair of values: the transformed matrix $\M M'$ and the transformation $\M T$.
If such transformation can not be found, raise $FuchsiaError$.

\functionitem{simplify\_by\_jordanification}{\M M, x}
Try to simplify a system defined by matrix $\M M$ and independent variable $x$ by constant transformations that transform leading expansion coefficients of $\M M$ into their Jordan forms.
Return a pair of values: the simplified matrix $\M M'$ and the transformation $\M T$.
If none of the attempted transformations reduce the complexity of $\M M$ (as measured by $\F{matrix\_complexity}$), return the original matrix and the identity transformation.

\functionitem{simplify\_by\_factorization}{\M M, x}
Try to simplify a system defined by matrix $\M M$ and independent variable $x$ by a constant transformation that extracts common factors found in $\M M$ (if any).
Return a pair of values: the simplified matrix $\M M'$ and the transformation $\M T$.

\functionitem{matrix\_complexity}{\M M}
This function is used as a measure of matrix complexity by $\F{fuchsify}$ and simplification function.
Currently it is defined as the length of textual representation of matrix $\M M$.

\functionitem{balance}{\M P, x_1, x_2, x}
Return a \textit{balance} transformation between points $x=x_1$ and $x=x_2$ using projector matrix $\M P$.

\functionitem{transform}{\M M, x, \M T}
Transform a system defined by matrix $\M M$ and independent variable $x$ using transformation matrix $\M T$.
Return the transformed matrix $\M M'$.

\functionitem{balance\_transform}{\M M, \M P, x_1, x_2, x}
Same as $\F{transform}(\M M, x, \F{balance}(\M P, x_1, x_2, x))$, but implemented more efficiently: since the inverse of $\F{balance}(\M P, x_1, x_2, x)$ is $\F{balance}(\M P, x_2, x_1, x)$, this function can avoid a time-consuming matrix inversion operation that $\F{transform}$ must perform.

\functionitem{singularities}{\M M, x}
Find values of $x$ around which matrix $\M M$ has a singularity in $x$.
Return a dictionary with $\{x_i: p_i\}$ entries, where $p_i$ is the Poincar\'e rank of $\M M$ at $x=x_i$.
The set of singular points can include $Infinity$, if $\M M$ has a singularity at $x\to\infty$.

\functionitem{matrix\_c0}{\M M, x, x_0, p}
Return the 0-th coefficient of the series expansion of matrix $\M M$ around $x=x_0$, assuming Poincar\'e rank of $\M M$ at that point is $p$.
If $x_0$ is $Infinity$, return the coefficient at the highest power of $x$.

\functionitem{matrix\_c1}{\M M, x, x_0, p}
Return the 1-th coefficient of the series expansion of matrix $\M M$ around $x=x_0$, assuming Poincar\'e rank of $\M M$ at that point is $p$.
If $x_0$ is $Infinity$, return the coefficient at the second-to-highest power of $x$.

\functionitem{matrix\_residue}{\M M, x, x_0}
Return matrix residue of matrix $\M M$ at $x=x_0$, assuming that Poincar\'e rank of $\M M$ at $x=x_0$ is $0$.
Return matrix residue at infinity if $x=Infinity$.

\functionitem{export\_matrix\_to\_file}{filename, \M M, fmt="mtx"}
Write matrix $\M M$ to a file $filename$ using MatrixMarket array format if $fmt$ is $"mtx"$ (which is the default), or Mathematica format if $fmt$ is $"m"$.

\functionitem{import\_matrix\_from\_file}{filename}
Read a symbolic matrix from a file $filename$.
Both Mathematica and MatrixMarket array formats are supported.
The exact format will be autodetected.

\classitem{FuchsiaError}
This is the class of exceptions raised by \fuchsia routines.
It signifies inability to perform requested reduction. 

\end{description}


\section{Summary}
\label{sec:4}

In this paper we have presented \fuchsia, a program for reducing differential equations for Feynman master integrals to canonical form.
\fuchsia is free and open-source: it is build in \python using \maximasage computer algebra system which are available free of charge.
To find the corresponding analytical transformation \fuchsia uses a method proposed by Roman Lee~\cite{Lee15}, which consists of three main computational steps: fuchsification, normalization, and factorization.

In additional, an optimization for block-triangular (or sparse) matrices is also implemented, which allows to reduce relatively large matrices: the reduction of ${74\times74}$ matrix with 20 real and complex singular points and at most $3\times3$ coupled blocks takes about an hour on a laptop with Intel i5 CPU.
In spite of that we still have difficulties to reduce somewhat smaller matrices with complex singular points due to the lack of support of factorization of polynoms with complex coefficients in \maximasage system, which we hope to improve in the next version of the program.
Another promising direction for improvements could be support for multivariate polynomials and symbolic singular points, which would allow to reduce differential equations for multi-scale Feynman master integrals.

\section*{Acknowledgment}

We gratefully acknowledge discussions with Roman Lee and Costas Papadopolous, examples of differential equations they provided are very much appreciated.

This work has been supported by Narodowe Centrum Nauki with the Sonata Bis grant DEC-2013/10/E/ST2/00656.

\bibliography{fuchsia}

\end{document}
